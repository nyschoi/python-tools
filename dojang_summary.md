# Chap~7
```python
print(1, 2, 3, sep=', ', end='')
a, b, c = 10, 20, 30
x = y = z = 10
a, b = map(float, input().split())
print(f'{a:0>10.1f}')
```
## operator

### compare
```python
'Python' == 'Python'
'Python' == 'python'
'Python' != 'python'
10 > 20
10 < 20
10 >= 10
10 <= 10
1 == 1.0  # true
1 is not 1.0  # object 비교
id(1)
id(1.0)
```

### logical
* True로 취급: 0이 아닌 숫자, 내용이 있는 (문자열, 리스트, 튜플, 딕셔너리, 세트)
* False로 취급: 0, None, 비어 있는 (문자열, 리스트, 튜플, 딕셔너리, 세트)
```python
True and True
True or True
not True
```

### bit op
```python
# &, |, ^, ~, <<, >>,
bin(0b1101 & 0b1001)
# '0b1001'
13 & 9  # 비트 AND
# 9
bin(0b1101 | 0b1001)  # 비트 OR
# '0b1101'
13 | 9  # 비트 OR
# 13
bin(0b1101 ^ 0b1001)  # 비트 XOR
# '0b100'
13 ^ 9  # 비트 XOR
# 4
bin(~0b1101)  # 비트 NOT
# '-0b1110'
~13  # 비트 NOT
# -14

0b0011 << 2  # 비트를 왼쪽으로 2번 이동
# 12
bin(12)
# '0b1100'
```

# list
```python
리스트 = [값, 값, 값]         # 리스트 만들기
리스트 = []                   # 빈 리스트 만들기
리스트 = list()               # 빈 리스트 만들기
리스트 = list(range(횟수))    # range로 리스트 만들기
 
리스트[인덱스]                # 리스트의 요소에 접근
리스트[0]                     # 리스트의 인덱스는 0부터 시작하므로 첫 번째 요소
리스트[인덱스] = 값           # 리스트의 요소에 값 저장

append(값) # 리스트 끝에 값을 추가, 리스트[len(리스트):] = [값]과 같음
append(리스트) # 리스트를 넣으면 리스트 안에 리스트가 들어감
extend(리스트) # 리스트 끝에 다른 리스트 연결, 리스트[len(리스트):] = [값, 값]과 같음

insert(인덱스, 값) # 리스트의 특정 인덱스에 값을 추가
pop() # 리스트의 마지막 값을 삭제한 뒤 삭제한 값을 반환
pop(인덱스) # 인덱스를 지정하면 해당 인덱스의 값을 삭제한 뒤 삭제한 값을 반환, del 리스트[인덱스]와 같음
remove(값) # 리스트에서 특정 값을 삭제
index(값) # 리스트에서 특정 값의 인덱스를 구함
count(값) # 리스트에서 특정 값의 개수를 구함
reverse() # 리스트에서 값의 순서를 반대로 뒤집음
sort() # 리스트의 값을 작은 순서대로 정렬(오름차순)
sort(reverse=True) # reverse=True는 큰 순서대로 정렬(내림차순)
clear() # 리스트의 모든 값을 삭제, del a[:]와 같음
copy() # 리스트를 복사하여 새 리스트 생성

# 리스트는 메서드를 사용하지 않고, 인덱스로 범위를 지정하여 조작할 수 있습니다.
리스트[len(리스트):] = [값]        # 리스트 끝에 값이 한 개 들어있는 리스트 추가
                                   # 리스트.append(값)과 같음
리스트[len(리스트):] = [값, 값]    # 리스트 끝에 다른 리스트 연결
                                   # 리스트.extend([값, 값])과 같음
del 리스트[인덱스]    # 특정 인덱스의 값 삭제, 리스트.pop(인덱스)와 같음
del 리스트[:]   # 시작 인덱스와 끝 인덱스를 생략하여 리스트의 모든 값을 삭제, 리스트.clear()와 같음

for 변수 in 리스트:    # 반복하면서 요소를 꺼내옴
    반복할 코드
 
for 인덱스, 요소 in enumerate(리스트):    # 반복하면서 인덱스와 요소를 꺼내옴
    반복할 코드
 
for 인덱스 in range(len(리스트)):    # 리스트의 길이로 반복
    리스트[인덱스]                   # 인덱스로 요소에 접근
 
while 인덱스 < len(리스트):    # 리스트의 길이로 반복
    리스트[인덱스]             # 인덱스로 요소에 접근
    인덱스 += 1

min(), max(), sum() # min은 리스트(튜플)에서 가장 작은 값, max는 가장 큰 값, sum은 요소의 합계

```
# range
```python
range(횟수)
range(시작, 끝)
range(시작, 끝, 증가폭)
```

# tuple
```python
튜플 = (값, 값, 값)          # 튜플 만들기
튜플 = 값, 값, 값            # 괄호 없이 튜플 만들기
튜플 = ()                    # 빈 튜플 만들기
튜플 = tuple()               # 빈 튜플 만들기
튜플 = tuple(list())         # tuple에 list()를 넣어서 빈 튜플 만들기
튜플 = tuple(range(횟수))    # range로 튜플 만들기
 
튜플[인덱스]                 # 튜플의 요소에 접근
 
튜플 = (값, )                # 요소가 한 개인 튜플 만들기
튜플 = 값,                   # 요소가 한 개인 튜플 만들기
```
# sequence data types
list, tuple, str... -> sequence object. element -> 각 값
## sequence data type의 공통 기능
```python
값 in 시퀀스객체             # 시퀀스 객체에 특정 값이 있는지 확인
값 not in 시퀀스객체         # 시퀀스 객체에 특정 값이 없는지 확인
 
시퀀스객체1 + 시퀀스객체2    # 시퀀스 객체를 서로 연결하여 새 시퀀스 객체를 만듦
시퀀스객체 * 정수            # 시퀀스 객체를 특정 횟수만큼 반복하여 새 시퀀스 객체를 만듦
정수 * 시퀀스객체            # 시퀀스 객체를 특정 횟수만큼 반복하여 새 시퀀스 객체를 만듦
 
len(시퀀스객체)              # 시퀀스 객체의 요소 개수(길이) 구하기
 
시퀀스객체[인덱스]           # 시퀀스 객체의 요소에 접근
시퀀스객체[0]                # 시퀀스 객체의 인덱스는 0부터 시작하므로 첫 번째 요소
시퀀스객체[-음수]            # 인덱스를 음수로 지정하면 뒤에서부터 요소에 접근, -1은 뒤에서 첫 번째
시퀀스객체[인덱스] = 값      # 시퀀스 객체의 요소에 값 저장
 
del 시퀀스객체[인덱스]       # 시퀀스 객체의 요소를 삭제
```
## sequence type: slicing
```python
시퀀스객체[시작인덱스:끝인덱스]                 # 지정된 범위의 요소를 잘라서 새 시퀀스 객체를 만듦
시퀀스객체[시작인덱스:끝인덱스:인덱스증가폭]    # 인덱스 증가폭을 지정하면 해당 값만큼 
                                                # 인덱스를 증가시키면서 요소를 가져옴
 
시퀀스객체[:끝인덱스]      # 시작 인덱스를 생략하여 객체의 처음부터 끝 인덱스 - 1까지 가져옴
시퀀스객체[시작인덱스:]    # 끝 인덱스를 생략하여 시작 인덱스부터 마지막 요소까지 가져옴
시퀀스객체[:]              # 시작 인덱스와 끝 인덱스를 생략하여 객체 전체를 가져옴
 
시퀀스객체[0:len(시퀀스객체)]     # len을 응용하여 객체 전체를 가져옴
시퀀스객체[:len(시퀀스객체)]      # 시작 인덱스 생략, len을 응용하여 객체 전체를 가져옴
 
시퀀스객체[:끝인덱스:증가폭]      # 객체의 처음부터 증가폭만큼 인덱스를 증가시키면서 
                                  # 끝 인덱스 - 1까지 요소를 가져옴
시퀀스객체[시작인덱스::증가폭]    # 시작 인덱스부터 증가폭만큼 인덱스를 증가시키면서 
                                  # 마지막 요소까지 가져옴
시퀀스객체[::증가폭]              # 객체 전체에서 증가폭만큼 인덱스를 증가시키면서 요소를 가져옴
 
시퀀스객체[::]                    # 객체 전체를 가져옴, 시퀀스객체[:]와 같음
 
시퀀스객체[시작인덱스:끝인덱스] = 시퀀스객체                 # 범위를 지정하여 여러 요소에 값 할당
시퀀스객체[시작인덱스:끝인덱스:인덱스증가폭] = 시퀀스객체    # 증가폭만큼 인덱스를 건너뛰면서 할당
 
del 시퀀스객체[시작인덱스:끝인덱스]    # 특정 범위의 요소를 삭제(원본 객체가 변경됨)
```

## list(tuple)에 map 적용
```python
리스트 = list(map(함수, 리스트))
a = list(map(int, a))
튜플 = tuple(map(함수, 튜플))
 
변수1, 변수2 = list(map(함수, 리스트))    # 언패킹 사용
a, b = list(map(str, range(2)))
 
변수1, 변수2 = map(함수, 리스트)          # 언패킹 사용
a, b = map(int, input().split())
```
## 2차원 리스트
```python
리스트 = [[값, 값], [값, 값], [값, 값]]    # 2차원 리스트 만들기
리스트[세로인덱스][가로인덱스]         # 2차원 리스트의 요소에 접근
리스트[세로인덱스][가로인덱스] = 값    # 2차원 리스트의 요소에 값 저장
리스트 = [(값, 값), (값, 값), (값, 값)]    # 리스트 안에 튜플을 넣음
튜플 = ([값, 값], [값, 값], [값, 값])      # 튜플 안에 리스트를 넣음
튜플 = ((값, 값), (값, 값), (값, 값))      # 튜플 안에 튜플을 넣음

리스트 = [[[값, 값], [값, 값]], [[값, 값], [값, 값]], [[값, 값], [값, 값]]]    # 3차원 리스트 만들기
리스트[높이인덱스][세로인덱스][가로인덱스]         # 3차원 리스트의 요소에 접근
리스트[높이인덱스][세로인덱스][가로인덱스] = 값    # 3차원 리스트의 요소에 값 저장
```

#string
```python
replace('바꿀문자열', '새문자열') # 문자열 안의 문자열을 다른 문자열로 바꿈
translate(테이블) # 문자열 안의 문자를 다른 문자로 바꿈, str.maketrans('바꿀문자', '새문자')로 변환 테이블을 만들어야 함
split() # 공백을 기준으로 문자열을 분리하여 리스트로 만듦
split('기준문자열') # 기준 문자열을 지정하면 기준 문자열로 문자열을 분리
'*'.join(['a', 'b', 'c']) # 구분자 문자열과 문자열 리스트(튜플)의 요소를 연결하여 문자열로 만듦
'*'.join([str(x) for x in [1, 2, 3]])
upper() # lower(). upper는 문자열의 문자를 대문자로 바꾸고, lower는 소문자로 바꿈
lstrip(), rstrip(), strip() # lstrip은 문자열에서 왼쪽 공백을 삭제, rstrip은 오른쪽 공백을 삭제, strip은 양쪽 공백을 삭제, 삭제할 문자들을 지정하면 해당 문자들을 삭제
lstrip('삭제할문자들')
rstrip('삭제할문자들')
strip('삭제할문자들')
ljust(길이), rjust(길이), center(길이) # 문자열을 지정된 길이로 만든 뒤 왼쪽(ljust), 오른쪽(rjust), 가운데(center)로 정렬하며 남는 공간은 공백으로 채움
zfill() # 지정된 길이에 맞춰서 문자열의 왼쪽에 0을 채움
find('찾을문자열') # find는 왼쪽에서부터, rfind는 오른쪽에서부터 특정 문자열을 찾아서 인덱스 반환, 문자열이 없으면 -1을 반환
rfind('찾을문자열')
index('찾을문자열') # index는 왼쪽에서부터, rindex는 오른쪽에서부터 특정 문자열을 찾아서 인덱스를 반환, 문자열이 없으면 에러 발생
rindex('찾을문자열')
count('문자열') # 현재 문자열에서 특정 문자열이 몇 번 나오는지 알아냄
```


# dict
```python
딕셔너리 = {키1: 값1, 키2: 값2}    # 딕셔너리 만들기
딕셔너리 = {}                      # 빈 딕셔너리 만들기
딕셔너리 = dict()                  # 빈 딕셔너리 만들기
 
딕셔너리[키]                       # 딕셔너리에서 키로 값에 접근
딕셔너리[키] = 값                  # 딕셔너리에서 키에 값 할당
 
키 in 딕셔너리                     # 딕셔너리에 특정 키가 있는지 확인
키 not in 딕셔너리                 # 딕셔너리에 특정 키가 없는지 확인
 
len(딕셔너리)                      # 딕셔너리의 키 개수(길이) 구하기

setdefault(키, 기본값) # 딕셔너리에 키-값 쌍을 추가, 키만 지정하면 값에 None을 저장
x.update(a=900, f=60)
x.update({1: 'one', 2: 'two', 3: 'three', '4': 'four'})
x.update([['a', 'b'], [3, 'd'], [123, 456]])
x.update(zip([1, 2], ['one', 'two']))
update(튜플)
update(반복가능한객체)

pop(키) # 딕셔너리에서 특정 키-값 쌍을 삭제한 뒤 값을 반환, del 딕셔너리[키]와 같음
pop(키, 기본값) # 기본값을 지정하면 키가 없을 때 기본 값을 반환

popitem() # 딕셔너리에서 임의의 키-값 쌍을 삭제하고 해당 키-값 쌍을 튜플로 반환

clear() # 딕셔너리의 모든 키-값 쌍을 삭제

get(키) # 딕셔너리에서 특정 키의 값을 가져옴
get(키, 기본값) # 기본값을 지정하면 키가 없을 때 기본값을 반환

items() # items는 딕셔너리의 키-값 쌍을 모두 가져옴
keys()           # keys는 딕셔너리의 키를 모두 가져옴
values() # values는 딕셔너리의 값을 모두 가져옴

copy() # 딕셔너리를 복사하여 새 딕셔너리 생성
dict.fromkeys(키리스트) # 리스트(튜플)로 딕셔너리를 만듦, 키 리스트만 지정하면 값은 모두 None이 저장됨
dict.fromkeys(키리스트, 값) # 키 리스트와 값을 지정하면 해당 값이 딕셔너리의 값으로 저장됨

for 변수 in 딕셔너리:              # 모든 키를 꺼내옴
    반복할 코드
 
for 키, 값 in 딕셔너리.items():    # 모든 키와 값을 꺼내옴
    반복할 코드
 
for 키 in 딕셔너리.keys():         # 모든 키를 꺼내옴
    반복할 코드
 
for 값 in 딕셔너리.values():       # 모든 값을 꺼내옴
    반복할 코드

딕셔너리 = {키1: {키A: 값A}, 키2: {키B: 값B}}    # 딕셔너리 안에 딕셔너리 넣기
 
딕셔너리[키][키]         # 딕셔너리 안에 있는 딕셔너리에서 값에 접근
딕셔너리[키][키] = 값    # 딕셔너리 안에 있는 딕셔너리에서 키에 값 할당
```

# set
```python
세트 = {값1, 값2, 값3}        # 세트 만들기
세트 = set(반복가능한객체)    # 세트 만들기
 
값 in 세트        # 세트에 특정 값이 있는지 확인
값 not in 세트    # 세트에 특정 값이 없는지 확인
 
len(세트)    # 세트의 요소 개수(길이) 구하기
set.union(세트1, 세트2) # | 
set.intersection(세트1, 세트2) # &
set.difference(세트1, 세트2) # -
set.symmetric_difference(세트1, 세트2)  # ^ 두 세트의 대칭차집합
update(다른세트) # |= 현재 세트에 다른 세트를 더함
intersection_update(다른세트) # &= 현재 세트와 다른 세트 중에서 겹치는 요소만 현재 세트에 저장
difference_update(다른세트) # -= 현재 세트에서 다른 세트를 뺌
symmetric_difference_update(다른세트) # ^= 현재 세트와 다른 세트 중에서 겹치지 않는 요소만 현재 세트에 저장
issubset(다른세트) # <= 현재 세트가 다른 세트의 부분집합인지 확인
<  # 현재 세트가 다른 세트의 진부분집합인지 확인

issuperset(다른세트) # >= 현재 세트가 다른 세트의 상위집합인지 확인
>  # 현재 세트가 다른 세트의 진상위집합인지 확인
isdisjoint(다른세트) # 현재 세트가 다른 세트와 겹치지 않는지 확인
add(요소) # 세트에 요소를 추가
remove(요소) # 세트에서 특정 요소를 삭제, 없으면 에러 발생
discard(요소) # 세트에서 특정 요소를 삭제, 요소가 없으면 그냥 넘어감
pop() # 세트에서 임의의 요소를 삭제하고 해당 요소를 반환
clear() # 세트에서 모든 요소를 삭제
copy() 
```



# file
```python
read() # 파일에서 문자열을 읽음
write('문자열') # 파일에 문자열을 씀
readline() # 파일의 내용을 한 줄 읽음
readlines() # 파일의 내용을 한 줄씩 리스트 형태로 가져옴
writelines(문자열리스트) # 파일에 리스트의 문자열을 씀, 리스트의 각 문자열에는 \n을 붙여주어야 함
pickle.load(파일객체) # 파일에서 파이썬 객체를 읽음
pickle.dump(객체, 파일객체) # 파이썬 객체를 파일에 저장
```

# func
```python

def 함수이름(매개변수1, 매개변수2):    # 위치 인수를 사용하는 함수
    코드
 
함수(*리스트)    # 리스트 언패킹
함수(*튜플)      # 튜플 언패킹

def 함수이름(*매개변수):    # 위치 인수를 사용하는 가변 인수 함수
    코드
 
함수(인수1, 인수2)    # 인수 여러 개를 직접 넣기
함수(*리스트)         # 리스트 언패킹
함수(*튜플)           # 튜플 언패킹

함수(키워드1=값1, 키워드2=값2)     # 함수를 키워드 인수 방식으로 호출
함수(**딕셔너리)    # 딕셔너리 언패킹

def 함수이름(**매개변수):    # 키워드 인수를 사용하는 가변 인수 함수
    코드
 
함수(키워드1=값1, 키워드2=값2)    # 키워드 인수를 직접 넣기
함수(**딕셔너리)                  # 딕셔너리 언패킹
```

# lambda func
```python
lambda 매개변수1, 매개변수2: 반환값                    # 람다 표현식으로 함수를 만듦
(lambda 매개변수1, 매개변수2: 반환값)(인수1, 인수2)    # 람다 표현식 자체를 호출
 
lambda 매개변수1, 매개변수2: 식1 if 조건식 else 식2    # 람다 표현식에서 조건부 표현식 사용
lambda x: str(x) if x % 3 == 0 else x
 
lambda 매개변수1, 매개변수2: 식1 if 조건식1 else 식2 if 조건식2 else 식3  # if를 여러 개 사용
lambda x: str(x) if x == 1 else float(x) if x == 2 else x + 10
```

# var scope
```python
z = 10
def A():
    x = 10
    y = 100
    global z    # 전역 변수 x를 사용하겠다고 설정
    z = 20      # x는 전역 변수
    def B():
        x = 20
        def C():
            nonlocal x
            nonlocal y
            x = x + 30
            y = y + 300
            print(x)  # 50
            print(y)  # 400
        C()
    B()
A()
print(z)  # 20  # 전역 변수 z를 사용하겠다고 설정
```